<candidate>
#include <tops/tops_runtime.h>
#include <tops.h>

static constexpr int M_T = 16;
static constexpr int N_T = 64;    // N 仍取 64 以降低 L1 压力
static constexpr int K_T = 128;

__global__ void kernel_gemm_safe_fast(float *lhs, float *rhs, float *out,
                                      int M, int K, int N,
                                      bool is_lhs_T, bool is_rhs_T, bool is_out_T)
{
  const int T   = GetThreadNum();
  const int tid = GetThreadIdx();

  // L3 视图（两种 layout 都备好）
  int32_t g_lhs_MK[2] = {M, K};
  int32_t g_lhs_KM[2] = {K, M};
  int32_t g_rhs_KN[2] = {K, N};
  int32_t g_rhs_NK[2] = {N, K};
  int32_t g_out_MN[2] = {M, N};
  int32_t g_out_NM[2] = {N, M};

  tops::mdspan G_LHS_MK(tops::Global, lhs, g_lhs_MK);
  tops::mdspan G_LHS_KM(tops::Global, lhs, g_lhs_KM);
  tops::mdspan G_RHS_KN(tops::Global, rhs, g_rhs_KN);
  tops::mdspan G_RHS_NK(tops::Global, rhs, g_rhs_NK);
  tops::mdspan G_OUT_MN(tops::Global, out, g_out_MN);
  tops::mdspan G_OUT_NM(tops::Global, out, g_out_NM);

  // DTE（同步，简单稳）
  tops_dte_ctx_t dteA, dteB, dteT, dteO;
  dteA.init(); dteB.init(); dteT.init(); dteO.init();

  // L1 缓冲（单缓冲 + 必要时转置临时区）
  __valigned__ float A_blk     [M_T * K_T];  // [m_sz, k_sz]
  __valigned__ float B_blk     [K_T * N_T];  // [k_sz, n_sz]
  __valigned__ float A_tmp     [K_T * M_T];  // [k_sz, m_sz] (仅 lhs 需要转置时用)
  __valigned__ float B_tmp     [N_T * K_T];  // [n_sz, k_sz] (仅 rhs 需要转置时用)
  __valigned__ float C_blk     [M_T * N_T];  // [m_sz, n_sz]
  __valigned__ float C_blk_T   [N_T * M_T];  // out 转置写回时用

  const int mt = (M + M_T - 1) / M_T;
  const int nt = (N + N_T - 1) / N_T;
  const int kt = (K + K_T - 1) / K_T;

  // (m,n) tile 扁平化分配
  const int W = mt * nt;
  int active_T = T; if (active_T > W) active_T = W;
  if (tid >= active_T) { dteA.destroy(); dteB.destroy(); dteT.destroy(); dteO.destroy(); return; }
  const int base  = W / active_T;
  const int extra = W % active_T;
  const int my_cnt = base + (tid < extra ? 1 : 0);
  const int my_beg = tid * base + (tid < extra ? tid : extra);

  const int VLEN = tops::vlength<vfloat>(); // 32

  for (int t = 0; t < my_cnt; ++t) {
    const int p  = my_beg + t;
    const int mi = p / nt;    // tile m index
    const int nj = p % nt;    // tile n index

    const int m0  = mi * M_T;
    const int n0  = nj * N_T;
    const int m_sz = (m0 + M_T <= M) ? M_T : (M - m0);
    const int n_sz = (n0 + N_T <= N) ? N_T : (N - n0);

    // C 清零
    for (int i = 0; i < m_sz * n_sz; ++i) C_blk[i] = 0.f;

    // K 维累加
    for (int kk = 0; kk < kt; ++kk) {
      const int k0  = kk * K_T;
      const int k_sz = (k0 + K_T <= K) ? K_T : (K - k0);

      // --- 装 A 成 [m_sz, k_sz] ---
      if (!is_lhs_T) {
        int offA[2] = {m0, k0};
        tops::slice(dteA,
          tops::mdspan(tops::Private, A_blk, m_sz, k_sz),
          G_LHS_MK, offA);
      } else {
        // 从 KxM 切块为 [k_sz, m_sz] 再转成 [m_sz, k_sz]
        int offA0[2] = {k0, m0};
        tops::slice(dteA,
          tops::mdspan(tops::Private, A_tmp, k_sz, m_sz),
          G_LHS_KM, offA0);
        int layoutA[2] = {1, 0};
        tops::transpose(dteT,
          tops::mdspan(tops::Private, A_blk, m_sz, k_sz),
          tops::mdspan(tops::Private, A_tmp, k_sz, m_sz),
          layoutA);
      }

      // --- 装 B 成 [k_sz, n_sz] ---
      if (!is_rhs_T) {
        int offB[2] = {k0, n0};
        tops::slice(dteB,
          tops::mdspan(tops::Private, B_blk, k_sz, n_sz),
          G_RHS_KN, offB);
      } else {
        // 从 NxK 切块为 [n_sz, k_sz] 再转成 [k_sz, n_sz]
        int offB0[2] = {n0, k0};
        tops::slice(dteB,
          tops::mdspan(tops::Private, B_tmp, n_sz, k_sz),
          G_RHS_NK, offB0);
        int layoutB[2] = {1, 0};
        tops::transpose(dteT,
          tops::mdspan(tops::Private, B_blk, k_sz, n_sz),
          tops::mdspan(tops::Private, B_tmp, n_sz, k_sz),
          layoutB);
      }

      // --- L1 计算：矢量化优先 ---
      const int A_rs = k_sz;      // A 行步长
      const int B_rs = n_sz;      // B 行步长
      const int C_rs = n_sz;      // C 行步长
      const bool vec_ok = (n_sz % VLEN == 0);

      for (int im = 0; im < m_sz; ++im) {
        float * __restrict C_row = &C_blk[im * C_rs];
        float * __restrict A_row = &A_blk[im * A_rs];

        if (vec_ok) {
          for (int kcur = 0; kcur < k_sz; ++kcur) {
            const float a = A_row[kcur];
            const auto  a_v = tops::vbroadcast<vfloat>(a);
            float * __restrict B_row = &B_blk[kcur * B_rs];

            int j = 0;
            for (; j + VLEN <= n_sz; j += VLEN) {
              auto c = tops::vload<vfloat>(C_row + j);            // void* OK
              auto b = tops::vload<vfloat>(B_row + j);
              c = tops::vadd<vfloat>(c, tops::vmul<vfloat>(a_v, b));
              tops::vstore(c, C_row + j);
            }
            // 理论上 j==n_sz，这里只是保险
            for (; j < n_sz; ++j) C_row[j] += a * B_row[j];
          }
        } else {
          for (int kcur = 0; kcur < k_sz; ++kcur) {
            const float a = A_row[kcur];
            float * __restrict B_row = &B_blk[kcur * B_rs];
            for (int j = 0; j < n_sz; ++j) C_row[j] += a * B_row[j];
          }
        }
      }
    } // for kk

    // --- 写回 ---
    if (!is_out_T) {
      int offC[2] = {m0, n0};
      tops::deslice(dteO,
        G_OUT_MN,
        tops::mdspan(tops::Private, C_blk, m_sz, n_sz),
        offC);
    } else {
      // 手工转置到 [n_sz, m_sz] 再 deslice
      for (int i = 0; i < m_sz; ++i)
        for (int j = 0; j < n_sz; ++j)
          C_blk_T[j * m_sz + i] = C_blk[i * n_sz + j];

      int offCT[2] = {n0, m0};
      tops::deslice(dteO,
        G_OUT_NM,
        tops::mdspan(tops::Private, C_blk_T, n_sz, m_sz),
        offCT);
    }
  }

  dteA.destroy(); dteB.destroy(); dteT.destroy(); dteO.destroy();
}

void GCU_GEMM(float *__restrict dev_lhs, float *__restrict dev_rhs, float *__restrict dev_out,
              const int m, const int k, const int n,
              bool is_lhs_transpose, bool is_rhs_transpose, bool is_out_transpose)
{
  if (m <= 0 || n <= 0 || k <= 0) return;

  int maxT = 12; // gcu210
  topsDeviceProp_t prop;
  if (topsGetDeviceProperties(&prop, 0) == topsSuccess) {
    if (prop.maxThreadsPerMultiProcessor < maxT) maxT = prop.maxThreadsPerMultiProcessor;
  }

  const int mt = (m + M_T - 1) / M_T;
  const int nt = (n + N_T - 1) / N_T;
  const int W  = mt * nt;

  int T = (W < maxT) ? W : maxT;
  if (T < 1) T = 1;

  kernel_gemm_safe_fast<<<dim3(1,1,1), dim3(T,1,1)>>>(
    dev_lhs, dev_rhs, dev_out, m, k, n,
    is_lhs_transpose, is_rhs_transpose, is_out_transpose);

  (void)topsGetLastError();
  (void)topsDeviceSynchronize();
}
</candidate>

<score>59.13</score>
<log>testcase0 -> Passed
testcase1 -> Passed
testcase2 -> Passed
testcase3 -> Passed
testcase4 -> Passed
testcase5 -> Passed
testcase6 -> Passed
testcase7 -> Passed
testcase8 -> Passed
testcase9 -> Passed</log>


<candidate>
#include <tops/tops_runtime.h>
#include <tops.h>

static constexpr int M_T = 16;
static constexpr int N_T = 64;    // 仍用 64，L1 更安全
static constexpr int K_T = 128;

__global__ void kernel_gemm_stable_v4(float *lhs, float *rhs, float *out,
                                      int M, int K, int N,
                                      bool is_lhs_T, bool is_rhs_T, bool is_out_T)
{
  const int T   = GetThreadNum();
  const int tid = GetThreadIdx();

  // L3 视图
  int32_t g_lhs_MK[2] = {M, K};
  int32_t g_lhs_KM[2] = {K, M};
  int32_t g_rhs_KN[2] = {K, N};
  int32_t g_rhs_NK[2] = {N, K};
  int32_t g_out_MN[2] = {M, N};
  int32_t g_out_NM[2] = {N, M};

  tops::mdspan G_LHS_MK(tops::Global, lhs, g_lhs_MK);
  tops::mdspan G_LHS_KM(tops::Global, lhs, g_lhs_KM);
  tops::mdspan G_RHS_KN(tops::Global, rhs, g_rhs_KN);
  tops::mdspan G_RHS_NK(tops::Global, rhs, g_rhs_NK);
  tops::mdspan G_OUT_MN(tops::Global, out, g_out_MN);
  tops::mdspan G_OUT_NM(tops::Global, out, g_out_NM);

  // DTE（同步）
  tops_dte_ctx_t dte_lhs2d, dte_rhs2d, dte_out;
  dte_lhs2d.init(); dte_rhs2d.init(); dte_out.init();

  // L1 缓冲
  __valigned__ float lhs2d     [M_T * K_T];  // [m_sz, k_sz]
  __valigned__ float rhs2d     [K_T * N_T];  // [k_sz, n_sz]
  __valigned__ float lhs2d_tmp [K_T * M_T];  // [k_sz, m_sz]
  __valigned__ float rhs2d_tmp [N_T * K_T];  // [n_sz, k_sz]
  __valigned__ float out_tile  [M_T * N_T];  // [m_sz, n_sz]
  __valigned__ float out_tile_T[N_T * M_T];  // [n_sz, m_sz] —— 专用于手工转置写回

  const int m_tiles = (M + M_T - 1) / M_T;
  const int n_tiles = (N + N_T - 1) / N_T;
  const int k_tiles = (K + K_T - 1) / K_T;

  // 线性铺开 (m,n) tiles，连续分段分配
  const int W = m_tiles * n_tiles;
  int active_T = T; if (active_T > W) active_T = W;
  if (tid >= active_T) { dte_lhs2d.destroy(); dte_rhs2d.destroy(); dte_out.destroy(); return; }
  const int base  = W / active_T;
  const int extra = W % active_T;
  const int my_cnt = base + (tid < extra ? 1 : 0);
  const int my_beg = tid * base + (tid < extra ? tid : extra);

  const int VLEN = tops::vlength<vfloat>(); // 32

  for (int t = 0; t < my_cnt; ++t) {
    const int p   = my_beg + t;
    const int mi  = p / n_tiles;
    const int nj  = p % n_tiles;
    const int m0  = mi * M_T;
    const int n0  = nj * N_T;
    const int m_sz = (m0 + M_T <= M) ? M_T : (M - m0);
    const int n_sz = (n0 + N_T <= N) ? N_T : (N - n0);

    // 清零
    for (int i = 0; i < m_sz * n_sz; ++i) out_tile[i] = 0.f;

    // K 累加
    for (int kk = 0; kk < k_tiles; ++kk) {
      const int k0  = kk * K_T;
      const int k_sz = (k0 + K_T <= K) ? K_T : (K - k0);

      // LHS → L1 统一成 [m_sz, k_sz]
      if (!is_lhs_T) {
        int off[2] = {m0, k0};
        tops::slice(dte_lhs2d,
                    tops::mdspan(tops::Private, lhs2d, m_sz, k_sz),
                    G_LHS_MK, off);
      } else {
        int offA[2] = {k0, m0};
        tops::slice(dte_lhs2d,
                    tops::mdspan(tops::Private, lhs2d_tmp, k_sz, m_sz),
                    G_LHS_KM, offA);
        int layout[2] = {1, 0};
        tops::transpose(dte_lhs2d,
                        tops::mdspan(tops::Private, lhs2d, m_sz, k_sz),
                        tops::mdspan(tops::Private, lhs2d_tmp, k_sz, m_sz),
                        layout);
      }

      // RHS → L1 统一成 [k_sz, n_sz]
      if (!is_rhs_T) {
        int offB[2] = {k0, n0};
        tops::slice(dte_rhs2d,
                    tops::mdspan(tops::Private, rhs2d, k_sz, n_sz),
                    G_RHS_KN, offB);
      } else {
        int offB2[2] = {n0, k0};
        tops::slice(dte_rhs2d,
                    tops::mdspan(tops::Private, rhs2d_tmp, n_sz, k_sz),
                    G_RHS_NK, offB2);
        int layout2[2] = {1, 0};
        tops::transpose(dte_rhs2d,
                        tops::mdspan(tops::Private, rhs2d, k_sz, n_sz),
                        tops::mdspan(tops::Private, rhs2d_tmp, n_sz, k_sz),
                        layout2);
      }

      // L1 GEMM：仅当 n_sz%32==0 才向量化；否则标量
      const int A_rs = k_sz;
      const int B_rs = n_sz;
      const int C_rs = n_sz;
      const bool vec_ok = (n_sz % VLEN == 0);

      for (int im = 0; im < m_sz; ++im) {
        float* C_row = &out_tile[im * C_rs];
        float* A_row = &lhs2d  [im * A_rs];

        if (vec_ok) {
          for (int kcur = 0; kcur < k_sz; ++kcur) {
            const float a = A_row[kcur];
            const auto  a_v = tops::vbroadcast<vfloat>(a);
            float* B_row = &rhs2d[kcur * B_rs];

            int j = 0;
            for (; j + VLEN <= n_sz; j += VLEN) {
              auto c = tops::vload<vfloat>(C_row + j);
              auto b = tops::vload<vfloat>(B_row + j);
              c = tops::vadd<vfloat>(c, tops::vmul<vfloat>(a_v, b));
              tops::vstore(c, C_row + j);
            }
            // 保险收尾（理论 j==n_sz）
            for (; j < n_sz; ++j) C_row[j] += a * B_row[j];
          }
        } else {
          for (int kcur = 0; kcur < k_sz; ++kcur) {
            const float a = A_row[kcur];
            float* B_row  = &rhs2d[kcur * B_rs];
            for (int j = 0; j < n_sz; ++j) C_row[j] += a * B_row[j];
          }
        }
      }
    } // kk

    // 写回：不再用 transpose_deslice，统一“手工转置 + deslice”
    if (!is_out_T) {
      int offOut[2] = {m0, n0};
      tops::deslice(dte_out,
                    G_OUT_MN,
                    tops::mdspan(tops::Private, out_tile, m_sz, n_sz),
                    offOut);
    } else {
      // 手工转置到 out_tile_T: [n_sz, m_sz]
      for (int i = 0; i < m_sz; ++i) {
        for (int j = 0; j < n_sz; ++j) {
          out_tile_T[j * m_sz + i] = out_tile[i * n_sz + j];
        }
      }
      int offOutT[2] = {n0, m0};
      tops::deslice(dte_out,
                    G_OUT_NM,
                    tops::mdspan(tops::Private, out_tile_T, n_sz, m_sz),
                    offOutT);
    }
  } // tiles

  dte_lhs2d.destroy(); dte_rhs2d.destroy(); dte_out.destroy();
}

void GCU_GEMM(float *__restrict dev_lhs, float *__restrict dev_rhs, float *__restrict dev_out,
              const int m, const int k, const int n,
              bool is_lhs_transpose, bool is_rhs_transpose, bool is_out_transpose)
{
  if (m <= 0 || n <= 0 || k <= 0) return;

  int maxT = 12; // gcu210
  topsDeviceProp_t prop;
  if (topsGetDeviceProperties(&prop, 0) == topsSuccess) {
    if (prop.maxThreadsPerMultiProcessor < maxT) maxT = prop.maxThreadsPerMultiProcessor;
  }

  const int m_tiles = (m + M_T - 1) / M_T;
  const int n_tiles = (n + N_T - 1) / N_T;
  int W = m_tiles * n_tiles;
  int T = (W < maxT) ? W : maxT;
  if (T < 1) T = 1;

  kernel_gemm_stable_v4<<<dim3(1,1,1), dim3(T,1,1)>>>(
      dev_lhs, dev_rhs, dev_out, m, k, n,
      is_lhs_transpose, is_rhs_transpose, is_out_transpose);

  (void)topsGetLastError();
  (void)topsDeviceSynchronize();
}
</candidate>

<score>59.77</score>
<log>testcase0 -> Passed
testcase1 -> Passed
testcase2 -> Passed
testcase3 -> Passed
testcase4 -> Passed
testcase5 -> Passed
testcase6 -> Passed
testcase7 -> Passed
testcase8 -> Passed
testcase9 -> Passed</log>


<candidate>
#include <tops/tops_runtime.h>
#include <tops.h>

static constexpr int M_T = 16;
static constexpr int N_T = 64;    // N 仍取 64 以降低 L1 压力
static constexpr int K_T = 128;

__global__ void kernel_gemm_safe_fast(float *lhs, float *rhs, float *out,
                                      int M, int K, int N,
                                      bool is_lhs_T, bool is_rhs_T, bool is_out_T)
{
  const int T   = GetThreadNum();
  const int tid = GetThreadIdx();

  // L3 视图（两种 layout 都备好）
  int32_t g_lhs_MK[2] = {M, K};
  int32_t g_lhs_KM[2] = {K, M};
  int32_t g_rhs_KN[2] = {K, N};
  int32_t g_rhs_NK[2] = {N, K};
  int32_t g_out_MN[2] = {M, N};
  int32_t g_out_NM[2] = {N, M};

  tops::mdspan G_LHS_MK(tops::Global, lhs, g_lhs_MK);
  tops::mdspan G_LHS_KM(tops::Global, lhs, g_lhs_KM);
  tops::mdspan G_RHS_KN(tops::Global, rhs, g_rhs_KN);
  tops::mdspan G_RHS_NK(tops::Global, rhs, g_rhs_NK);
  tops::mdspan G_OUT_MN(tops::Global, out, g_out_MN);
  tops::mdspan G_OUT_NM(tops::Global, out, g_out_NM);

  // DTE（同步，简单稳）
  tops_dte_ctx_t dteA, dteB, dteT, dteO;
  dteA.init(); dteB.init(); dteT.init(); dteO.init();

  // L1 缓冲（单缓冲 + 必要时转置临时区）
  __valigned__ float A_blk     [M_T * K_T];  // [m_sz, k_sz]
  __valigned__ float B_blk     [K_T * N_T];  // [k_sz, n_sz]
  __valigned__ float A_tmp     [K_T * M_T];  // [k_sz, m_sz] (仅 lhs 需要转置时用)
  __valigned__ float B_tmp     [N_T * K_T];  // [n_sz, k_sz] (仅 rhs 需要转置时用)
  __valigned__ float C_blk     [M_T * N_T];  // [m_sz, n_sz]
  __valigned__ float C_blk_T   [N_T * M_T];  // out 转置写回时用

  const int mt = (M + M_T - 1) / M_T;
  const int nt = (N + N_T - 1) / N_T;
  const int kt = (K + K_T - 1) / K_T;

  // (m,n) tile 扁平化分配
  const int W = mt * nt;
  int active_T = T; if (active_T > W) active_T = W;
  if (tid >= active_T) { dteA.destroy(); dteB.destroy(); dteT.destroy(); dteO.destroy(); return; }
  const int base  = W / active_T;
  const int extra = W % active_T;
  const int my_cnt = base + (tid < extra ? 1 : 0);
  const int my_beg = tid * base + (tid < extra ? tid : extra);

  const int VLEN = tops::vlength<vfloat>(); // 32

  for (int t = 0; t < my_cnt; ++t) {
    const int p  = my_beg + t;
    const int mi = p / nt;    // tile m index
    const int nj = p % nt;    // tile n index

    const int m0  = mi * M_T;
    const int n0  = nj * N_T;
    const int m_sz = (m0 + M_T <= M) ? M_T : (M - m0);
    const int n_sz = (n0 + N_T <= N) ? N_T : (N - n0);

    // C 清零
    for (int i = 0; i < m_sz * n_sz; ++i) C_blk[i] = 0.f;

    // K 维累加
    for (int kk = 0; kk < kt; ++kk) {
      const int k0  = kk * K_T;
      const int k_sz = (k0 + K_T <= K) ? K_T : (K - k0);

      // --- 装 A 成 [m_sz, k_sz] ---
      if (!is_lhs_T) {
        int offA[2] = {m0, k0};
        tops::slice(dteA,
          tops::mdspan(tops::Private, A_blk, m_sz, k_sz),
          G_LHS_MK, offA);
      } else {
        // 从 KxM 切块为 [k_sz, m_sz] 再转成 [m_sz, k_sz]
        int offA0[2] = {k0, m0};
        tops::slice(dteA,
          tops::mdspan(tops::Private, A_tmp, k_sz, m_sz),
          G_LHS_KM, offA0);
        int layoutA[2] = {1, 0};
        tops::transpose(dteT,
          tops::mdspan(tops::Private, A_blk, m_sz, k_sz),
          tops::mdspan(tops::Private, A_tmp, k_sz, m_sz),
          layoutA);
      }

      // --- 装 B 成 [k_sz, n_sz] ---
      if (!is_rhs_T) {
        int offB[2] = {k0, n0};
        tops::slice(dteB,
          tops::mdspan(tops::Private, B_blk, k_sz, n_sz),
          G_RHS_KN, offB);
      } else {
        // 从 NxK 切块为 [n_sz, k_sz] 再转成 [k_sz, n_sz]
        int offB0[2] = {n0, k0};
        tops::slice(dteB,
          tops::mdspan(tops::Private, B_tmp, n_sz, k_sz),
          G_RHS_NK, offB0);
        int layoutB[2] = {1, 0};
        tops::transpose(dteT,
          tops::mdspan(tops::Private, B_blk, k_sz, n_sz),
          tops::mdspan(tops::Private, B_tmp, n_sz, k_sz),
          layoutB);
      }

      // --- L1 计算：矢量化优先 ---
      const int A_rs = k_sz;      // A 行步长
      const int B_rs = n_sz;      // B 行步长
      const int C_rs = n_sz;      // C 行步长
      const bool vec_ok = (n_sz % VLEN == 0);

      for (int im = 0; im < m_sz; ++im) {
        float * __restrict C_row = &C_blk[im * C_rs];
        float * __restrict A_row = &A_blk[im * A_rs];

        if (vec_ok) {
          for (int kcur = 0; kcur < k_sz; ++kcur) {
            const float a = A_row[kcur];
            const auto  a_v = tops::vbroadcast<vfloat>(a);
            float * __restrict B_row = &B_blk[kcur * B_rs];

            int j = 0;
            for (; j + VLEN <= n_sz; j += VLEN) {
              auto c = tops::vload<vfloat>(C_row + j);            // void* OK
              auto b = tops::vload<vfloat>(B_row + j);
              c = tops::vadd<vfloat>(c, tops::vmul<vfloat>(a_v, b));
              tops::vstore(c, C_row + j);
            }
            // 理论上 j==n_sz，这里只是保险
            for (; j < n_sz; ++j) C_row[j] += a * B_row[j];
          }
        } else {
          for (int kcur = 0; kcur < k_sz; ++kcur) {
            const float a = A_row[kcur];
            float * __restrict B_row = &B_blk[kcur * B_rs];
            for (int j = 0; j < n_sz; ++j) C_row[j] += a * B_row[j];
          }
        }
      }
    } // for kk

    // --- 写回 ---
    if (!is_out_T) {
      int offC[2] = {m0, n0};
      tops::deslice(dteO,
        G_OUT_MN,
        tops::mdspan(tops::Private, C_blk, m_sz, n_sz),
        offC);
    } else {
      // 手工转置到 [n_sz, m_sz] 再 deslice
      for (int i = 0; i < m_sz; ++i)
        for (int j = 0; j < n_sz; ++j)
          C_blk_T[j * m_sz + i] = C_blk[i * n_sz + j];

      int offCT[2] = {n0, m0};
      tops::deslice(dteO,
        G_OUT_NM,
        tops::mdspan(tops::Private, C_blk_T, n_sz, m_sz),
        offCT);
    }
  }

  dteA.destroy(); dteB.destroy(); dteT.destroy(); dteO.destroy();
}

void GCU_GEMM(float *__restrict dev_lhs, float *__restrict dev_rhs, float *__restrict dev_out,
              const int m, const int k, const int n,
              bool is_lhs_transpose, bool is_rhs_transpose, bool is_out_transpose)
{
  if (m <= 0 || n <= 0 || k <= 0) return;

  int maxT = 12; // gcu210
  topsDeviceProp_t prop;
  if (topsGetDeviceProperties(&prop, 0) == topsSuccess) {
    if (prop.maxThreadsPerMultiProcessor < maxT) maxT = prop.maxThreadsPerMultiProcessor;
  }

  const int mt = (m + M_T - 1) / M_T;
  const int nt = (n + N_T - 1) / N_T;
  const int W  = mt * nt;

  int T = (W < maxT) ? W : maxT;
  if (T < 1) T = 1;

  kernel_gemm_safe_fast<<<dim3(1,1,1), dim3(T,1,1)>>>(
    dev_lhs, dev_rhs, dev_out, m, k, n,
    is_lhs_transpose, is_rhs_transpose, is_out_transpose);

  (void)topsGetLastError();
  (void)topsDeviceSynchronize();
}
</candidate>
<score>59.7</score>
<log>testcase0 -> Passed
testcase1 -> Passed
testcase2 -> Passed
testcase3 -> Passed
testcase4 -> Passed
testcase5 -> Passed
testcase6 -> Passed
testcase7 -> Passed
testcase8 -> Passed
testcase9 -> Passed
</log>
