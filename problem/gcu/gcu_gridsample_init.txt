<candidate>
#include <tops/tops_runtime.h>

// ===============================================
// GCU GridSample (nearest, zeros, align_corners=False)
// ===============================================
__attribute__((global, cooperative))
void kernel_gridsample(float *__restrict inp,
                       float *__restrict grid,
                       float *__restrict out,
                       const int N, const int C,
                       const int IH, const int IW,
                       const int OH, const int OW) {
    // Thread info
    int thread_idx = threadIdx.x;
    int thread_num = blockDim.x;

    // DTE context
    tops_dte_ctx_t dte_in, dte_out, dte_grid;
    dte_in.init();
    dte_out.init();
    dte_grid.init();

    // L1 buffer
    __local__ __valigned__ char l1_buffer[104000];
    int used = 0;
    float *patch_inp = reinterpret_cast<float *>(l1_buffer + used);
    used += sizeof(float) * 64; // just small buffer
    float *grid_buf = reinterpret_cast<float *>(l1_buffer + used);
    used += 2 * sizeof(float);

    // Split work by batch
    int n_per_thread = (N + thread_num - 1) / thread_num;
    int n_start = thread_idx * n_per_thread;
    int n_end = (n_start + n_per_thread < N) ? (n_start + n_per_thread) : N;

    for (int n = n_start; n < n_end; ++n) {
        // 遍历输出坐标
        for (int oh = 0; oh < OH; ++oh) {
            for (int ow = 0; ow < OW; ++ow) {
                // 读取 grid[n, oh, ow, :]
                {
                    int grid_idx = ((n * OH + oh) * OW + ow) * 2;
                    tops::mdspan g_g(tops::Global, grid + grid_idx, 2);
                    tops::mdspan g_p(tops::Private, grid_buf, 2);
                    tops::memcpy(dte_grid, g_p, g_g);
                }

                float gx = grid_buf[0];
                float gy = grid_buf[1];

                // align_corners=False
                float ix = ((gx + 1.f) * IW - 1.f) * 0.5f;
                float iy = ((gy + 1.f) * IH - 1.f) * 0.5f;

                int ix_n = (int)(ix + 0.5f);
                int iy_n = (int)(iy + 0.5f);

                bool inside = (ix_n >= 0 && ix_n < IW && iy_n >= 0 && iy_n < IH);

                for (int c = 0; c < C; ++c) {
                    float val = 0.f;
                    if (inside) {
                        int inp_idx = ((n * C + c) * IH + iy_n) * IW + ix_n;
                        tops::mdspan g_in(tops::Global, inp + inp_idx, 1);
                        tops::mdspan p_in(tops::Private, patch_inp, 1);
                        tops::memcpy(dte_in, p_in, g_in);
                        val = patch_inp[0];
                    } else {
                        val = 0.f;
                    }

                    int out_idx = ((n * C + c) * OH + oh) * OW + ow;
                    tops::mdspan g_out(tops::Global, out + out_idx, 1);
                    tops::mdspan p_out(tops::Private, &val, 1);
                    tops::memcpy(dte_out, g_out, p_out);
                }
            }
        }
    }

    dte_in.destroy();
    dte_out.destroy();
    dte_grid.destroy();
}

// ===============================================
// Host wrapper
// ===============================================
void GCU_GridSample(float *__restrict dev_inp,
                    float *__restrict dev_grid,
                    float *__restrict dev_out,
                    const int N, const int C,
                    const int IH, const int IW,
                    const int OH, const int OW) {
    static const size_t blocks = 1;
    static const size_t threads = 12; // gcu210 typical
    kernel_gridsample<<<blocks, threads>>>(dev_inp, dev_grid, dev_out, N, C, IH, IW, OH, OW);
}
</candidate>
<score>55.93</score>
<log>testcase0 -> Passed
testcase1 -> Passed
testcase2 -> Passed
testcase3 -> Passed
testcase4 -> Passed
testcase5 -> Passed
testcase6 -> Passed
testcase7 -> Passed
testcase8 -> Passed
testcase9 -> Passed
</log>